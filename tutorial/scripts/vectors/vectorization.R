# c1 - обычный (поэлементный) подход; c2 - использование векторизации
a <- c(1,2,3); b <- c(4,5,6)
c1 <- vector() # создаём пустой вектор
# Вместо того,чтобы делать так:
for (i in 1:3) {
  c1[i] <- a[i] + b[i] # с1 обязательно нужно заранее создать
}
# Проще сделать так:
c2 <- a + b

# Создание логического индекса
a <- c(6,-2,1,8,0,9)
ind_a <- a > 0
ind_a

# Выбрать положительные элементы а
a[a > 0] # или a[ind_a]
# Подсчитать их количество...
length(a[ind_a])
# ... или сумму
sum(a[a > 0])

# Примеры использования логических операций
a <- c(6,-2,1,8,0,9)
a > 0 & a < 9
a < 2 | a > 8
any(a>0)
all(a>0)

# Пропуски в данных влияют на результаты вычислений. 
# Проверка выполняется функцией is.na.
#
# Данные с пропусками:
a <- c(6,-2,NA,1,8,0,NA,9)
# Их сумма даёт:
sum(a)
# Является ли элемент пропуском в данных?
is.na(a)
# Вычисление суммы, с учётом проверки на пропуски в данных
sum( a[!is.na(a)] )

#### Вычисление определённого интеграла $\int_1^2 x^2 dx$.

a <- 1; b <- 2             # границы промежутка интегрирования
n <- 1000                  # число узлов интегрирования
x <- seq(a,b,length.out=n) # координаты узлов сетки
h <- x[2]-x[1]             # шаг сетки
y <- x^2                   # значения подынтегральной функции в узлах сетки

# Точное значение интеграла
7/3

# Метод прямоугольников
sd<- h*sum(y[-length(y)])  # Нижняя интегральная сумма
su<- h*sum(y[-1])          # Верхняя интегральная сумма

# Метод трапеций
(su+sd)/2
