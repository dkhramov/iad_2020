####  Пример классификации с помошью кластерного анализа
####  Версия 26.02.2017

##  Шаг 1. Чтение данных

# Обеспечиваем, чтобы файл beverage.csv находился 
# в рабочей папке

setwd("week_03/data")
beverage.01 <- read.table("beverage.csv", header=T, sep=";")

##   Шаг 2. Удаление пропущенных значений

# В данной задаче пропущенных значений нет.
# Удалять нечего.
# В будущем, чтобы удалить строки, которые содержат пропущенные значения, закодированные NA
# beverage.02 <- na.omit(beverage.01)

##   Шаг 3. Стандартизация переменных.

# В данной задаче переменные измерены в одной и той же шкале.
# В порядке исключения стандартизировать не надо.
# В будущем, чтобы стандартизировать столбцы

# Вариант 1 - к среднему 0 и ст. отклонению 1
# beverage.02 <- scale(beverage.01[,2:9], center = TRUE, scale = TRUE)
# Вариант 2 - к минимуму 0 и максимуму 1
# maxs <- apply(beverage.01[,2:9] 2, max)
# mins <- apply(beverage.01[,2:9], 2, min)
# beverage.02 <- scale(beverage.01[,2:9], center = mins, scale = maxs - mins)
# Вариант 3 - использовать rescaler функцию из пакета reshape
# Вариант 4 - использовать data.Normalization функцию из пакета clusterSim

##  Шаг 4. Процедура кластерного анализа

# Создаем матрицу попарных расстояний

dist.beverage <- dist(beverage.01[,2:9])

# Проводим кластерный анализ, 
# результаты записываем в список clust.beverage

clust.beverage <- hclust(dist.beverage, "ward.D")

# Разница между ward.D и ward.D2  
# http://stats.stackexchange.com/questions/109949/what-algorithm-does-ward-d-in-hclust-implement-if-it-is-not-wards-criterion

#  Смотрим краткую сводку результатов анализа

clust.beverage

## Call:
## hclust(d = dist.beverage, method = "ward.D")
##
## Cluster method : ward.D
## Distance : euclidean
## Number of objects: 34

# Обычно предыдущие действия объединяют в одну команду

# clust.beverage <- hclust(dist(beverage.01[,2:9]), "ward.D")
# clust.beverage

# Если нам нужно расстояние, которое не реализовано 
# в функции dist, то создаем матрицу расстояний Х, 
# и приписываем ей класс dist командой as.dist(X)

##  Шаг 5.  Построение дендрограммы

plot(clust.beverage)

##  Шаг 6. Определение числа кластеров

# Ответ: 3 кластера (а может быть 2...)

# Сделаем красиво.
# На дендрограмме красными прямоугольниками выделим 3 кластера

rect.hclust(clust.beverage, k=3, border="red") 

# Разделим наблюдения на 3 кластера
# Вектор groups содержит номер кластера, в который попал 
# классифицируемый объект 

groups <- cutree(clust.beverage, k=3) 
groups

# Необязательно, чтобы кластеры нумеровались слева направо.
# Проверьте: у нас не так.
# Какой номер у левого, центрального и правого кластера?

# Что общего у объектов одного кластера? 
# Чем отличаются объекты в разных кластерах?

# Для каждого напитка определяем, 
# какой процент потребителей в кластере пил этот напиток

#  в 1-ом кластере
colMeans(beverage.01[groups==1, 2:9])*100
#  во 2-ом кластере
colMeans(beverage.01[groups==2, 2:9])*100
#  в 3-ем кластере
colMeans(beverage.01[groups==3, 2:9])*100

# Вариант интерпретации:
# 3-й кластер: поклонники диетических напитков и здорового образа жизни.
# 2-й кластер: любители "классики".
# 1-й кластер: недостаточный объем выборки не позволяет интерпретировать этот кластер. 

#  Что произойдет, если выберем решение с двумя кластерами?

##  Отступление
##  Обзор результатов процедуры кластерного анализа

# какие результаты хранятся в списке clust.beverage?
names(clust.beverage)

# история объединения кластеров
clust.beverage$merge
# Если перед номером кластера '-', то это исходный кластер.
# Если минуса нет, то это кластер, полученный в результате объединения. 
# Номер созданного кластера равен номеру строки.

# расстояния между кластерами в момент объединения
clust.beverage$height
# 0.0 означает совпадающие объекты

# порядок следования объектов на дендрограмме
clust.beverage$order

# метки классифицируемых объектов
clust.beverage$labels
# Метки - это названия объектов. Пока они не заданы.

# метод вычисления расстояний между кластерами
clust.beverage$method

# текст выполняемой команды
clust.beverage$call

# метод вычисления расстояний между объектами
clust.beverage$dist.method

# На основе известного числа шагов объединения кластеров 
# и расстояний между кластерами в момент объединения 
# строим график "каменистая осыпь"
nclust <- seq(length(clust.beverage$height),1,-1)
plot(nclust, clust.beverage$height, type = "b",
     xlab = "Number of clusters", 
     ylab = "Height",
     main = "Scree plot")

