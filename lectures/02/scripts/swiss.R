#### Знакомство с R. Набор данных Swiss Bank Notes.
#### Версия 26.02.2016

# Задача: предложить процедуру, которая различала бы фальшивые и подлинные
# банкноты Швейцарии.
# Описание данных находится в файле Swiss Bank Notes_описание.doc

# Не забыть установить рабочий каталог, R ищет данные в нем.
setwd("week_02/data")

## Шаг 1. Читаем данные, они находятся в файле Swiss_Bank_Notes_R

# В результате получится таблица с данными, которую будем называть swiss.01
swiss.01 <- read.table("Swiss Bank Notes.dat", header=TRUE, sep="", dec=",")
# read.table - это функция.
# В круглых скобках - аргументы функции.
# "Swiss Bank Notes.dat" - путь к файлу с данными по отношению к рабочему
# каталогу.
# header - указываем, есть в первой строке названия переменных, или нет.
# sep - указываем, какой символ отделяет поля данных.
# dec - символ, который отделяет десятичные знаки.

# Результат импорта не показан.
# Чтобы посмотреть, что получилось, чтобы убедиться, что все правильно,
# наберем
swiss.01

# Дальше я постоянно буду вызывать созданные объекты,
# чтобы проверить себя и убедиться, что все хорошо

## Шаг 2. Добавляется новый столбец – индикатор типа банкнот.

# Информация, какие банкноты подлинные, а какие нет, представлена неудобно.
# Удобнее, когда присутствует столбец-индикатор.
# Создадим его и назовем этот столбец origin.
# Код '1' = банкнота подлинная, код '0' = банкнота фальшивая.
# Новую таблицу с данными будем называть swiss.02

# 1-й вариант решения

# Создадим вектор, первые 100 элементов равны 1, следующие 100 - 0
origin <- c(rep(1, 100), rep(0, 100))
# Объединяем таблицу и вектор в новую таблицу
swiss.02 <- data.frame(swiss.01, origin)
swiss.02
# Присвоение в R записывается <- или =

## Типы данных в R

# Проверка типа данных у объекта
class(swiss.02)

# Скаляр — скаляров в R нет. Скаляр — это вектор длины 1
# Векторы
# - числовые (numeric)
# - текстовые (character)
# - логические (logical)
# - факторы (factors) (о них позднее)
# - временные ряды (ts) (о них позднее)
# Матрицы (matrix)
# Таблицы (data.frame) (вытесняется data.table)
# Cписок (list)

# 2-й вариант решения

# сначала удалим данные из памяти для чистоты эксперимента
rm(swiss.02, origin)

# Команда rm(имя, имя, имя)
# Удаляет перечисленные в скобках объекты из пути поиска и  
# тем самым очищает память.
# Команда rm(list = ls(all = TRUE)) полностью очищает память
swiss.02 <- swiss.01
swiss.02$origin <- c(rep(1, 100), rep(0, 100))

# 3-й вариант решения

# сначала удалим данные из памяти для чистоты эксперимента
rm(swiss.02, origin)
origin <- 0

# Разберитесь, как объединяется таблица и скаляр…
swiss.02 <- data.frame(swiss.01, origin)
swiss.02$origin[1:100] <-1
swiss.02

# проверяем имена переменных: проверим себя, вдруг что-то забыли
names(swiss.02)

## Шаг 3. Выполнение программ (скриптов) в R

# Сначала удалим всю информацию из памяти
# rm(swiss.01, swiss.02, origin)

# Теперь выполним программу
# возможно, придется редактировать строку, в которой читается файл
# source("script_1")

## Шаг 4. Знакомство с данными. Описательные статистики.

dim(swiss.02)

# Для векторов length(swiss.02)
nrow(swiss.02)
ncol(swiss.02)
str(swiss.02)
summary(swiss.02)

## Шаг 5. Гистограмма.

# Вариант 1. Все параметры задаются по умолчанию
hist(swiss.02$dist_up)
hist(swiss.02$Diag)

# Вопрос: что измеряется на вертикальной оси координат?
# по умолчанию ширина столбца вычисляется по правилу “Sturges”.
# По правилу Sturges'а число столбцов k = log2(n)+1
# breaks = "Scott"
# breaks = "Freedman-Diaconis".

# Вариант 2. Задаем число столбцов, 
# остальные параметры задаются по умолчанию
hist(swiss.02$dist_up, breaks=18)
hist(swiss.02$Diag, breaks=18)

# Вопрос: Почему столбцов гистограммы не 18?

# Вариант 3. Задаем число столбцов и способ вычисления высоты столбца,
# остальные параметры задаются по умолчанию
hist(swiss.02$dist_up, breaks=18, probability=TRUE)

# Дополнительно. При построении гистограммы можно задавать границы
# интервалов, над которыми строятся столбики. Как-то так...
hist(x, breaks=b, ...)
# Но для этого надо предварительно заготовить вектор b
# с координатами точек – границ интервалов

## Шаг 6. Столбиковая диаграмма.

# Строим столбиковую диаграмму
# Пример. Смертность в штате Вирджиния - находится во в 
# поставляемом вместе с набором данных VADeaths. 
# Посмотрим его:
VADeaths

barplot(VADeaths, beside=TRUE, legend=TRUE, ylim=c(0, 90),
        ylab="Deaths per 1000", main="Death rates in Virginia")

# Вопрос: в чем разница с гистограммой?

## Шаг 7. Круговая диаграмма.

groupsizes <- c(18, 30, 32, 10, 10)
labels <- c("A", "B", "C", "D", "F")
pie(groupsizes, labels, col=c("grey40", "white", "grey", "black", "grey90"))

## Шаг 8. Диаграмма рассеивания.

# Строим диаграмму рассеивания
plot(swiss.02$Length, swiss.02$Diag)

## Шаг 9. Использование цвета на графике.

# Вариант 1
# Строим диаграмму рассеивания, при этом точки, соответствующие фальшивым
# и подлинным банкнотам отмечаем разными символами.
# Сначала рисуем пустые оси координат, смасштабированные
# «правильным образом»
plot(swiss.02$Length, swiss.02$Diag, type="n", xlab="Length",
     ylab="Diagonal", main="Swiss Bank Notes")
# Добавляем точки, соответствующие подлинным банкнотам
points(swiss.02$Length[swiss.02$origin==1],
       swiss.02$Diag[swiss.02$origin==1],pch=3)
# Добавляем точки, соответствующие фальшивым банкнотам
points(swiss.02$Length[swiss.02$origin==0],
       swiss.02$Diag[swiss.02$origin==0],pch=1)
# Обратите внимание на разницу между = и ==

# Вариант 2
# Строим диаграмму рассеивания, точки, соответствующие фальшивым и
# подлинным банкнотам отмечаем разными символами и разным цветом.
plot(swiss.02$Length, swiss.02$Diag, type="n", xlab="Length",
     ylab="Diagonal", main="Swiss Bank Notes")
points(swiss.02$Length[swiss.02$origin==1],
       swiss.02$Diag[swiss.02$origin==1],pch=3, col=3)
points(swiss.02$Length[swiss.02$origin==0],
       swiss.02$Diag[swiss.02$origin==0],pch=1, col=6)

## Шаг 10. Матрица диаграмм рассеивания

# Вариант 1
plot(swiss.02)
# Вариант 2
pairs(swiss.02)
# Просто для сведения:
pairs(swiss.01, main = "Швейцарские банкноты",
      pch = c(21), cex = 1, bg = c("red","green")[as.factor(swiss.02$origin)])

## Шаг 11. Факторы.

# Что понимается под фактором? Зачем их вводить?
# объясняем пакету, что переменную origin надо считать фактором
swiss.02$origin <- as.factor(swiss.02$origin)

# проверяем, действительно ли переменная origin стала фактором
is.factor(swiss.02$origin)
class(swiss.02$origin)

## Шаг 12. Ящик с усами.

# строим ящик с усами, фактор должен быть указан первым...
plot(swiss.02$origin, swiss.02$Diag)

# если этого не сделать, если переменные поставить не в том порядке
# вместо ящика с усами получим…
plot(swiss.02$Diag, swiss.02$origin)

## Шаг 13. Добавление текста на график.

# так на график добавляется заголовок
title("Boxplot", "Swiss Bank Notes")
# Заголовок можно определять как опцию в команде, которая строит график…

# так на график добавляется заголовок и подписи осей
plot(swiss.02$Length, swiss.02$Diag, xlab="Length", ylab="Diagonal")
title("Swiss Bank Notes")

# заголовок и подписи осей можно добавлять и так
plot(swiss.02$Length, swiss.02$Diag,
     xlab="Length", ylab="Diagonal", main="Swiss Bank Notes")
# Такой перенос строки программа поймет:
# раз скобки не закрыты, значит ввод команды не завершен.
